#include "Header.h"
#include "Stack.h"

//Практическое занятие 1
//std::forward, std::ref, variadic функции, folds

int main()
{
	
	//1 std::ref()
	//Дана функция :
	//template<typename T> void fV(std::vector<T>&v) {
	//	for (auto& x : v) { ++x; }
	//}
{
	int a = 1, b = 2, c = 3;
	
	// Используем std::ref для создания ссылок на переменные a, b и c
	std::vector<std::reference_wrapper<int>> v = { std::ref(a),std::ref(b), std::ref(c) }; 
	fV(v); //в результате вызова fV a,b,c должны измениться!!!
	// Проверяем результаты
	std::cout << "a: " << a << ", b: " << b << ", c: " << c << std::endl; // Должно вывести 2, 3, 4


}
/*********************************************************************************/
{
	//2 variadic - функция
	//для вектора со значениями любого типа, например, int
	std::vector<int> v{ 4,7, 1 };
	//требуется реализовать функцию insertunique(), которая может принимать любое количество значений любого типа и добавлять в вектор только те значения, которые:
	//• приводятся к типу элементов вектора
	//• и такого значения в векторе еще нет
	//например :
	// //insertunique(< ? ? ? >, 1.1, std::string("qwerty"), 5.2);

	// // Вызов insertunique с различными типами данных
	insertunique(v, 1.1, std::string("qwerty"), 5.2, 7, 3, 4, 5);
	// Вывод результата
	for (const auto& elem : v) {
		std::cout << elem << " ";
	}
	//в результате в векторе должны быть значения : 4, 7, 1, 5
	//рекомендация : подумайте, как эффективнее передавать параметры!

}
/**********************************************************************************/
{
	//3 Способы реализации variadic - функций
	//Задание 3.а - без использования fold(С++14)
	//Посредством вызова variadic - функции требуется выполнить набор действий над одним и тем же значением, например: инкремент, декремент, вывод на печать... (в любом порядке, любое количество раз)
	//Уточнение 1 : значение может быть любого типа(для которого реализовано соответствующее действие)
	//Уточнение 2 : действие может быть реализовано посредством любого callable : функции(шаблон функции) или функтора(шаблона класса) (в частности посредством лямбда выражения)


	int x = 5;
	int delta = 8;

	// Набор действий: инкремент, вывод, декремент, вывод
	auto increment = [](int& val) { ++val; };
	auto decrement = [](int& val) { --val; }; 
	auto decrement_functor = [delta](int& val) { val=val-delta; };
	auto print = [](int& val) { std::cout << "Value: " << val << std::endl; };

	

	// Применение действий к значению x
	apply_actions(x, increment, print, increment_global, print, decrement, print, increment_template<int>,print, increment, print, decrement_functor, print);

}
{
//Задание 3.б - с использованием fold(С++17)
		int x = 5;
		

		// Набор действий: инкремент, вывод, декремент, вывод
		auto increment = [](int& val) { ++val; };
		auto decrement = [](int& val) { --val; };
		auto decrement_functor = [delta=8](auto & val) { val = val - delta; };
		auto print = [](int& val) { std::cout << "Value: " << val << std::endl; };

		// Применение действий к значению x
		apply_actions(x, increment, print, increment_global, print, decrement, print, increment_template<int>, print, increment, print, decrement_functor, print);
}

{
	//Задание 4.а - без использования fold(С++14)
	//Посредством вызова variadic - функции требуется выполнить одно и то же действие над набором операндов
	//Уточнение 1: значения операндов могут быть разного типа(для которого реализовано соответствующее действие)
	//Уточнение 2 : подумайте – можно ли реализовать действие посредством шаблона глобальной функции ?

	int x = 5;
	double y = 3.14;
	std::string z = "Hello";

	//Пример использования apply_to_all с шаблонной глобальной функцией
	apply_to_all(ActionFunctor(), x, y, z);
}
/**********************************************************************************/
{
	//5 Реализация шаблонного стека на базе односвязного списка.std::forward<>
	//Требуется обеспечить эффективное исполнение следующих операций(на примере простого класса Point, а в общем случае тип может быть сколь угодно сложный = > для него реализованы перемещающие операции = > это необходимо учесть при реализации стека) :
	MyStack<Point> s;
	Point pt(1, 1);
	s.push(pt); //добавить в стек копию lvalue
	s.push(Point(2, 2)); //переместить в стек из rvalue
	s.push_emplace(3, 3); //принять параметры, предназначенные конструктору и сконструировать «на месте»
	Point pt1(4, 4);
	s.push(pt, Point(5, 5), pt1, Point(6, 6)); //занести в стек любое количество параметров любой природы (lvalue, rvalue). *) – а если в стеке хотелось бы расположить эти значения в порядке следования параметров?
	MyStack <Point> s1(pt, Point(7, 7), pt1, Point(8, 8));

	//Для упрощения задачи – копирование, присваивание и перемещение стека запретим(это полезно, но напрямую не относится к теме занятия).
	//Замечание: односвязный список разрабатываем самостоятельно!А не заимствуем у стандартной библиотеки!!!
}
	return 0;
}